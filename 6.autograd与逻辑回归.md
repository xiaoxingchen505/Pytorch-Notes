

# Autograd——自动求导系统

## torch.autograd


<pre>
    <code>

torch.autograd.backward(tensors,
                        grad_tensors= None,
                        retain_graph = none, 
                        create_graph=False)
    </code>
</pre>

功能: 自动求取梯度


tensors: 用于求导的张量，如loss

retain_graph: 保存计算图

create_graph : 创建导数计算图，用于高阶求导

grad_tensors: 多梯度权重


<pre>
    <code>
     w = torch.tensor([1.],required_grad = True)
     x = torch.tensor([2.],required_grad = True)


    # 设置计算图
     a = torch.add(w, x)
     b = torch.add(w, 1)
     y = torch.mul(a, b)

     y.backward()
     print(w.grad)
    </code>
</pre>

最后print出来的w，应该是5

<pre>
    <code>
    y0 = torch.mul(a,b)     # y0 = (x+w) *(w+1)
    y1 = torch.add(a,b)     # y1 = (x+w) + (w+1)   dy1/dw = 2

    loss = torch.cat([y0,y1], dim=0)

    # grad tensor 是运用于多个梯度之间的权重设置
    grad_tensors = torch.tensor([1,2])
    loss.backward(gradient = gtad_tensors)
    </code>
</pre>


## torch.autograd.grad

<pre>
    <code>

torch.autograd.grad(outputs,
                    inputs,
                    grad_outputs= None,
                    retain_graph = none, 
                    create_graph=False)
    </code>
</pre>

功能:求取梯度

outputs: 用于求导的张量，比如loss

inputs: 需要梯度的张量

grad_outputs：多梯度权重

<pre>
    <code>
# 举例：利用 grad求二阶导数

x = torch.tensor([3.],requires_grad= True)
y = torch.pow(x, 2) # y = x**2

#必须create_graph设置为True，才能求二阶级导
grad_1 = torch.autograd.grad(y,x,create_graph= True) # grad_1 = dy/dx = 2x = 2* 3 = 6
print(grad_1)

grad_2 = torch.autograd.grad(grad_1[0], x) # grad_2 = d(dy/dx)/dx = d(2x)/dx = 2
print(grad_2)
        </code>
</pre>

### autograd 注意事项：

1.梯度不自动清零

2.依赖于叶子结点的节点， requires_grad 默认为 True

3.叶子结点不可执行in-place操作


# 逻辑回归

![image](https://github.com/xiaoxingchen505/Pytorch-Notes/blob/master/images/lr1.png)

线性回归是分析自变量x与因变量y(标量)之间关系的方法

逻辑回归是分析自变量x与因变量y(概率)之间关系的方法

### 逻辑回归也等价于对数几率回归

![image](https://github.com/xiaoxingchen505/Pytorch-Notes/blob/master/images/lr2.png)


<pre>
    <code>

# 第一步：生成数据

sample_nums = 100
mean_value = 1.7
bias = 1
n_data = torch.ones(sample_nums, 2)
x0 = torch.normal(mean_value * n_data, 1) + bias
y0 = torch.zeros(sample_nums)

x1 = torch.normal(-mean_value * n_data, 1) + bias
y01 = torch.zeros(sample_nums)

train_x = torch.cat((x0,x1),0)
train_x = torch.cat((y0,y1),0)
    </code>
</pre>

<pre>
    <code>

# 第二步: 选择模型

class LR(nn.Module):
    def __init__(self):
        super(LR,self).__init__()
        self.features = nn.Linear(2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.features(x)
        x = self.sigmoid(x)
        return x

lr_net = LR()
    </code>
</pre>

<pre>
    <code>
 # 第三步：选择损失函数
 loss_fn = nn.BCELoss()
    </code>
</pre>


<pre>
    <code>
 # 第四步：选择优化器
lr = 0.01 学习率
optimizer = torch.optim.SGD(lr_net.parameters(), lr = lr, momentum = 0.9)
    </code>
</pre>

<pre>
    <code>
 # 第五步：模型训练
for iteration in range(1000):

    # 前向传播 
    y_pred = lr_net(train_x)

    # 计算loss
    loss = loss_fn(y_pred.squeeze(), train_y)

    # 反向传播
    loss.backward()

    # 更新参数
    optimizer.step()

    # 绘图
    if iteration % 20 == 0:

        mask = y_pred.ge(0.5).float().squeeze() # 以0.5为阈值进行分类
        correct = (mask == train_y).sum() # 计算正确预测的样本个数
        acc = correct.item() / train_y.size(0) # 计算分类准确率

        plt.scatter(x0.data.numpy([:, 0]),x0.data.numpy()[:, 1], c='r', label = 'class 0')
        plt.scatter(x1.data.numpy([:, 0]),x1.data.numpy()[:, 1], c='b', label = 'class 1')

        w0, w1 = lr_net.features.weight[0]
        w0, w1 = float(w0.item()) , float(w1.item())
        plot_b = float(lr_net.features.bias[0].item())
        plot_x = np.arange(-6,6,0.1)
        plot_y = (-w0 *plot_x - plot_b) / w1

        plt.xlim(-5, 7)
        plt.ylim(-7, 7)

        plt.text(-5,5, 'Loss=%.4f'% loss.data.numpy(), fontdict={'size': 20 , 'color': ' red'})

        plt.title("Iteration: {}\nw0:{:.2f} w1:{:.2f} b:{:.2f} accuracy:{:.2%}".format(iteration, w0, w1, plot_b, acc))

        plt.legend()
        plt.show()
        plt.pause(0.5)

        if acc > 0.99:
            break
    </code>
</pre>
